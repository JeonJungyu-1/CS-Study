## 1. 인증(Authentication) & 인가(Authorization)👻

- **인증** : 자신을 인증할 요소를 통해 특정 개체의 신원을 확인하는 과정
- **인가** : 특정 객체가 특정 리소스에 접근할 수 있는 지 혹은 특정 동작을 수행할 수 있는 지 확인하는 과정

---

## 2. HTTP 프로토콜 특징👾

1. **Connectionless(비연결 지향)** : 요청에 맞는 응답을 보낸 후 연결을 끊는 처리 방식
2. **Statless(무상태)** : 클라이언트와 서버 간의 connection을 끊은 후에는 상태 정보를 유지하지 않는다.

> 💡 Stateful의 필요성 :  HTTP의 Connectionless, Statless 특징에 의해 이전 통신에서 주고 받은 데이터를 다음 통신에서 사용하지 못하게 되는데 실제 서비스를 살펴보면 이전 데이터들이 현재 통신을 처리하는데 필요한 경우가 많다. 예를 들어 회원용 API(ex. 장바구니 내역 확인 등)를 클라이언트가 호출 시 매번 클라이언트가 누구인지 인증을 해줘야 한다는 번거로움이 생긴다. 이러한 문제를 해결하기 위해 쿠키와 세션이 등장하였다.
> 

---

## 3. 쿠키(Cookie)란?🍪

 클라이언트가 특정 웹사이트에 접속 할 때 서버가 클라이언트의 상태 정보를 클라이언트의 로컬 pc에 저장하는 기록 정보 파일을 **‘쿠키’**라고 부른다.

- **쿠키 특징**
    - 이름, 값, 만료일, 경로 정보로 구성되어진다.
    - 4KB 정도의 저장 공간을 지닌다
    - session cookie와 persistent cookie로 구분된다.
        - **session cookie** : 만료일이 없고 브라우저나 탭이 열려 있는 동안에만 저장됨
        - **persistent cookie** : 만료일을 지닌 채 디스크에 저장되어 브라우저가 닫혀도 유지된다.
    - 매 요청 시 서버에 전달 되므로 크기가 클 경우 **서버에 부담이 갈 수도 있다.**
    - 유효 기간이 존재한다.(서버가 결정)
    - 세션 키 값을 지녀 서버가 클라이언트를 구분할 수 있도록 한다.
    - 문자열만 저장 가능하다.
    - 도메인에 국한된다.
        - 유튜브가 보내준 쿠키는 유튜브에만 보내지게 된다.
    - 요청 시 쿠키의 값을 그대로 보내 보안에 취약하다.
    - 브라우저간 쿠키 지원 형태가 달라 브라우저 간 공유가 불가능하다.
- **쿠키 동작 과정**
    1. 클라이언트가 웹 사이트에 접근
    2. 웹 서버가 쿠키 생성
    3. 응답을 보낼 때 생성한 쿠키를 함께 클라이언트에게 전달
    4. 쿠키를 클라이언트가 로컬 pc에 저장하고 있다가 추후에 다시 서버에 요청을 보낼 때 쿠키를 함께 전달
    5. 브라우저를 껐다가 다시 키고 동일 사이트 재방문 시 클라이언트의 로컬 pc에 쿠키가 남아있다면 요청 시 쿠키를 함께 전달한다.
- **예시**
    - 로그인 자동 완성
    - “오늘 하루 이 창을 다시 보지 않기” 팝업을 체크하면 서버가 쿠키 정보를 확인하여 팝업을 띄우지 않는다.

---

## 4. 쿠키 속성🍪

- Http 헤더에 쿠키에 대한 속성을 지정한다.
    - `Set-Cookie` : 클라이언트에게 쿠키를 저장하라고 지정, 만료 날짜를 지정할 수 있다.
    - `Cookie` : 쿠키를 클라이언트가 저장, Http 요청 시 서버로 전달

```java
{
  Set-Cookie:
		b_cookie=butter;
    Expires=Sat, 11 Feb 2023 16:35:00;
		Domain=naver.com;
		Path=/users;
		Secure;
    HttpOnly;
  ]
}

```

- `Name`: 쿠키 이름(b_cookie)
- `Value`: 쿠키에 저장된 값(butter)
- `Expires & Max-Age` : 쿠키의 만료 기간을 설정
    - Expires(날짜와 시간) 또는 Max-age(초)를 사용하여 만료 기간을 명시한다면 **Permanent Cookie**가 되고 그렇지 않다면 **Session Cookie**가 된다.
    - expires="`Wdy, DD−Mon−YYYY HH:MM:SS GMT`”
    - 만료 시간은 서버가 아닌 클라이언트를 기준으로 계산된다.
    - Expires와 MaxAge 모두 사용했다면 MaxAge가 우선 시 된다.
- `Domain`: 쿠키가 전송되는 도메인을 지정(**스코프 지정**)
    - 스코프에 현재 위치와 서브 도메인 모두 포함
        - [news.naver.com](http://news.naver.com/) / [email.naver.com](http://email.naver.com/) 과 같이 naver.com의 서브 도메인 또한 요청 시 쿠키를 서버에 전송하도록 지정
    - 지정한 domain 값이 탐색 중인 도메인과 일치하지 않을 경우 브라우저에서 거부 한다. ⇒ 이를 통해 특정 도메인에서 다른 도메인에 대한 쿠키를 사용하지 못하도록 한다.
- `Path` : 쿠키 스코프를 도메인 내 특정 경로로 제한
    - path에 지정한 값을 포함한 하위 경로로 요청할 때만 쿠키를 전송
    - ex. /Users ⇒ /Users를 포함한 경로일 때만 쿠키 전송
- `Secure` : Https 프로토콜에서만 쿠키를 전송
    - 스니핑으로부터 안전성 증가
- `HttpOnly` : 자바스크립트의 Document.cookie 객체를 통해 쿠키의 접근을 제한

---

## 5. 세션(Session)🤖

 일정 시간 동안 동일한 클라이언트로부터 오는 요청들은 하나의 같은 상태(단위)라 보고 그 상태를 유지 시키는 기술을 **‘세션’**이라고 부른다. 이때 일정 시간을 결정하는 기준은 브라우저가 웹 서버와 연결 되기 시작한 순간부터 끝날 때 까지 이다.(웹 서버의 저장되는 쿠키라고 생각)

- **세션 특징**
    - 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장
    - 저장 데이터의 제한이 없다
    - 클라이언트 마다 **고유 session id**를 부여한다.
    - 스니핑 당해도 정보가 세션 ID만 탈취당하기 때문에 보안이 쿠키 인증 방식 보단 좋지만 해커가 탈취한 세션 ID로 클라이언트인 척 위장할 수 있다.
    - 세션은 유저 정보를 서버에 저장하고 있기 때문에 **부가 기능**들을 유저에게 제공할 수 있다.
        - 넷플릭스 5명까지 인원 추가
        - 인스타그램 로그인 된 기기 확인 및 수정
        - 강제 로그아웃 가능
    - 세션DB는 주로 redis를 사용(빠르고 저렴)
- **세션 동작 과정**
    1. 클라이언트가 웹 사이트에 접근
    2. 서버가 접근한 클라이언트의 쿠키를 확인하여 session id가 있는지 확인
    3. session id가 없다면 서버가 생성하여 클라이언트에게 전달(생성된 session id는 session db에 저장)
    4. 클라이언트가 쿠키를 사용하여 받은 session id를 쿠키 or 로컬 스토리지에 저장
    5. 웹 사이트에 재접속 시 요청과 함께 쿠키에 저장된 session id를 전달
    6. 서버는 클라이언트로부터 받는 쿠키 내 세션 ID에 따라 세션 DB를 확인 후 사용자의 데이터(아이디 or 패스워드)를 읽는다.
- **서버에서 세션 정보 삭제 방법**
    - 사용자가 로그아웃 버튼 클릭 시
    - 클라이언트로 부터 특정 시간 동안 요청이 없을 경우 자동 로그아웃(세션 삭제)
- **예시**
    - 한 사이트 내에서 여러 페이지를 이동해도 로그인 상태가 유지 되는 것

<aside>
💡 쿠키와 세션은 함께 사용하여 동작한다!!!!
⇒ 쿠키를 통해 세션 ID를 클라이언트와 서버가 주고 받기 때문에

</aside>

---

## 6. Cookie인증과 Session인증의 차이😵‍💫

1. **사용자의 정보 저장 위치** : 쿠키는 클라이언트의 측에 저장되고 세션은 서버에 저장된다.
2. **보안** : 쿠키는 클라이언트의 로컬 PC에 저장되기 때문에 데이터가 변질될 수 있으며 쿠키 인증 방식을 사용할 경우 스니핑 당하면 클라이언트의 개인 정보가 그대로 노출되지만 세션 인증을 사용하면 스니핑 당할 경우 session id만 노출되어 비교적 보안성이 높다.
3. **라이프 사이클(Life Cycle)** : 쿠키는 로컬 pc 내에 저장되기 때문에 브라우저를 닫아도 유지될 수 있으며 따로 만료 기간을 지정할 수 있다. 반면 세션 또한 만료 기간을 지정할 순 있지만 클라이언트가 브라우저를 닫게 되면 세션 정보 또한 **만료 기간에 상관 없이 사라지게 된다**.

---

## 7. Token 인증 방식🪙

- 서버가 유저를 인증하는 필요한 정보를 **토큰에 저장**하고 이를 요청과 응답 때 주고 받는 방식.
- 등장 배경
    - 쿠키와 세션은 브라우저에만 존재하고 네이티브 앱(안드로이드, ios)에서는 사용할 수 없다. ⇒ 앱에서의 인증 인가 수단이 필요 ⇒ 이로 인해 토큰 등장
- 토큰 사용 전 서버
    - 현재 로그인한 유저들의 **모든 세션ID를 DB에 저장해야한다.**
    - 매 요청마다 서버에 존재하는 세션DB를 확인해야 한다. ⇒ **유저가 늘어남에 따라 DB 리소스가 더 필요**해진다.
- 특징
    - 기존 **세션 DB를 유지해야했던 서버의 부담을 해소**할 수 있다.
    - DB를 거치지 않고 요청과 함께 온 토큰의 **유효성만 검사**한다면 유저를 인증할 수 있다.
    - 클라이언트 측에 저장된다.
    - 문자열이다.
- 동작 과정
    1. 클라이언트가 요청에 사용자의 아이디 & 패스워드를 함께 보냄
    2. 서버는 서버 각자의 **사인 알고리즘**을 통해 사인을 한다.(유저의 아이디 또는 비밀번호를 통해 고유 식별 문자열 생성)
    3. 서버의 응답에 사인된 정보(토큰)를 string 형태로 전송
    4. 이를 클라이언트가 쿠키나 스토리지에 저장
    5. 다음 요청 때 사인된 정보(토큰)를 서버에 함께 보낸다. 
    6. 서버가 전달 받은 토큰의 유효성을 검사한다.
    7. 유효하다면 인증 완료

---

## 8. JWT🎃

- 토큰 형식이다.
- 스니핑에 대비하기 위해 Access Token, Refresh Token을 사용한다.
    - Access Token : 유저의 정보가 담긴 토큰으로, 서버가 유저를 인증할 때 사용한다.
    - Refresh Token : Access Token은 만료 기간이 짧아 새로운 Access Token을 발급하기 위해 사용하는 토큰으로 서버의 데이터베이스에 유저 정보와 함께 저장된다.
- 특징
    - 저장할 수 있는 정보의 길이에 대한 제약이 존재
    - Payload 자체는 암호화되어 있지 않기 때문에 중요한 데이터는 담을 수 없다.
- 사용 예시
    - QR 로그인 : QR코드 내 JWT가 들어있어서 서버가 이를 통해 인증 과정을 거친다.
- 동작 과정
    1. 클라이언트가 ID & PW를 요청과 함께 보냄
    2. 서버에서 요청에 따라 Header, PayLoad, Signature를 정의 및 Base64로 암호화 하여 JWT를 생성
    3. 응답을 보낼 때 쿠키에 JWT(AccessToken & Refresh Token)를 담아서 함께 보낸다.
    4. 클라이언트가 JWT를 로컬 스토리지 또는 쿠키에 저장
    5. 다시 요청을 보낼 때 Authorization header에 AccessToken을 담아서 보냄
    6. 서버가 받은 JWT의 유효성을 검사
    7. 검사에 통과하면 페이로드에 들어있는 클라이언트에서 요청하는 데이터들을 return
    8. 만약 토큰이 만료 됐다면 RefreshToken을 통해 Access Token 재발급

---

## 9. JWT 구성 요소🎃

![jwtImage](https://supertokens.com/static/b0172cabbcd583dd4ed222bdb83fc51a/9af93/jwt-structure.png)

- `Header`
    - alg : 서명 암호화 알고리즘
    - type : 토큰 유형
- `Payload` : 실제로 사용될 데이터에 대한 내용
    - 토큰에서 사용할 정보의 조각을 claim이라고 부르며 payload에는 claim들이 담겨있다.
    - `Registered  Claim` : 미리 정의 된 클레임
        - issu : 발행자
        - exp : 만료 시간
        - sub : 제목
        - iot : 발행 시간
        - jti : jwi id
    - `Public Claim` : 사용자가 정의할 수 있는 클레임
    - `Private Claim` : 특정 사람들 끼리 정보 공유를 위해 만들어진 사용자 지정 클레임
- `Signature` : 헤더 + 페이로드 + 서버의 고유 key를 조합하여 헤더에서 정의한 알고리즘으로 암호화 한 것
    - Signature는 서버 고유 key가 유출되지 않는 이상 스니핑 당해도 복호화 할 수 없다.

<br>

## 출처

[https://www.youtube.com/watch?v=tosLBcAX1vk](https://www.youtube.com/watch?v=tosLBcAX1vk)

[https://www.youtube.com/watch?v=gA1KsJ2ak10](https://www.youtube.com/watch?v=gA1KsJ2ak10)

[https://www.joinc.co.kr/w/man/12/cookie](https://www.joinc.co.kr/w/man/12/cookie)

[https://velog.io/@hellozin/쿠키-세션-그리고-웹-스토리지](https://velog.io/@hellozin/%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9B%B9-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80)

[https://velog.io/@xchdtk/HTTP-쿠키Cookie-세션Session의-이해](https://velog.io/@xchdtk/HTTP-%EC%BF%A0%ED%82%A4Cookie-%EC%84%B8%EC%85%98Session%EC%9D%98-%EC%9D%B4%ED%95%B4)

[https://not-to-be-reset.tistory.com/284](https://not-to-be-reset.tistory.com/284)

[https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)

[자료 수집 (1)](https://www.notion.so/1-df449742729d4d1d92004c2f1155937b)
