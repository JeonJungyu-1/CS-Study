# **SSR & CSR**

## ✅ Index

1. [SPA](#1-spa-란)
2. [SPA의 등장배경](#2-spa-등장배경)
3. [CSR](#3-csr)
4. [SEO](#4-seo검색엔진최적화)
5. [SSR](#5-ssr)
6. [TTV & TTI](#6-ttv--tti)
7. [SSG](#7-ssg)
8. [Universal Rendering](#8-universal-rendering)

---

## **1. SPA 란?**

: Single Page Application

- 한 개의 싱글 페이지로 구성된 어플리케이션
- 실제 서버에서 HTML을 거의 로드하지 않고 어플리케이션 시작시에 데이터 만 네트워크를 통해 전달
- 브라우저에 최초에 한번 페이지 전체를 로드하고, 이후부터는 특정 부분만 Ajax 를 통해 데이터를 바인딩하는 방식
- 대표적인 라이브러리/프론트프레임워크 : React, Vue, Angular

### **↔ MPA**

: Multi Page Application

- 여러개의 페이지로 구성된 application
- SSR 방식으로 렌더링
- 서버로부터 완전한 페이지를 받아오고 이후에 데이터를 수정, 조회할때 다른 완전한 페이지로 이동함 (URI 가 바뀌기도함)

<details>

<summary><b>🟢 SPA 와 CSR 은 같을까?</b></summary>
  <h3><span style = "color:red">NO</span></h3>
  SPA, MPA는 페이지를 하나만 쓰는지, 여러개 쓰는지의 차이이고
  CSR, SSR은 렌더링을 어디서 하냐의 차이로 비교 대상이 아니다. <br>
  SPA에서는 첫 페이지만 받아오고 이후에 데이터의 수정,조회를 하고 싶기 때문에 CSR이란 방식을 채택한 반면, <br>
  MPA는 동적이지 않은 페이지를 상황에 맞게 클라이언트에 뿌려주기 때문에 SSR이란 방식을 채택한 것
</details>
<br>
<br>

## **2. SPA 등장배경**

### 🟢 1990년대 중반 - **정적 웹사이트**

사용자가 브라우저에서 해당 사이트에 접속하면 이미 잘 만들어진 HTML 문서를 받아와서 보여주는 방식.

예를 들어 페이지 내에서 다른 링크를 클릭하면, 다시 서버에서 해당 페이지의 HTML 문서를 받아온 후 페이지 전체가 업데이트 되어야 한다. 사용성이 떨어지고 페이지마다 전체가 업데이트 되어야하는 단점이 있다.

### 🟢 1996년 - **iframe 태그**

문서 내에서 또 다른 문서를 담을 수 있는 iframe 태그가 도입이 되었고 이후 페이지 내에서 부분적으로 문서를 받아와서 업데이트 할 수가 있게 된다

### 🟢 1998년 ~ - **XMLHttpRequest**

Fetch API의 원조 XHR Web API가 개발이 되어 이제는 HTML 문서 전체가 아니라 JSON과 같은 포맷으로 서버에서 가볍게 필요한 데이터만 받아올 수 있게 된다.

해당 데이터를 자바스크립트를 이용해서 동적으로 HTML 요소를 생성한 후 페이지에 업데이트 하는 방식.

### 🟢 2005년 - **AJAX**

XHR과 같은 방식이 공식적인 AJAX라는 이름을 가지게 되고 AJAX를 이용해서 Gmail, Google Map 같은 웹 어플리케이션들이 만들어지기 시작한다.

이것이 현재 널리 쓰이고 있는 <span style="background-color:lightyellow"><b>SPA(Single Page Application)</b></span>이다. 사용자가 한 페이지 내에 머무르면서 필요한 데이터만 서버에서 받아와 부분적으로 업데이트 된다.

이런 SPA가 트렌드가 되고, 자바스크립트가 표준화과 되어가며 <u>React, Angular, Vue 와 같은 프레임워크, 라이브러리가 생겨 CSR의 시대가 오게됨</u>
<br>
<br>

> **SSR과 CSR의 가장 큰 차이는 언제 viewable 하느냐!**

## **3. CSR**

![CSR IMAGE](https://user-images.githubusercontent.com/96935132/219909894-fb8b1f5b-bc35-40c7-a185-6a8b9e8bd4f3.png)

### 🟢 **정의**

: Client Side Rendering ; 모든 랜더링을 브라우저에 맡긴다!

### 🟢 **과정**

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>CSR</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="app.js"></script>
  </body>
</html>
```

- body 안에는 root 만 달랑 하나 있고, 스크립트 링크만 작성되어있는 것을 확인할 수 있음<br>
  → html 은 텅텅 비어있고 링크된 자바스크립트(app.js)를 서버로부터 다운받는 형식<br>
  → 추가로 필요한 데이터가 있다면 서버에 요청해 받아온 데이터를 기반으로 동적인 HTML 을 생성하고 사용자에게 최종적으로 어플리케이션이 보여짐

### 🟢 **장점**

- 서버를 호출할 때마다 전체 UI를 다시 로드할 필요가 없음
  → 빠른 속도
- 변경된 부분만 요청함으로써 서버 부하를 줄임
- 페이지 안에 컨텐츠를 클릭하여 다음단계로 전환하는 과정에서 깜빡임 없이 부드럽게 이동하는 사용자 친화성 有

### 🟢 **단점**

- 사용자가 첫 화면을 보기까지 시간이 오래걸릴수있다
  - $\because$ 어플리케이션을 구동하는 프레임워크, 라이브러리 소스, 어플리케이션 로직들 등등 → 굉장히 사이즈가 커서 다운로드에 시간이 소요될수있음
  - [해결법]
    code splitting - url 마다 각각의 번들링된 js파일을 만들 수 있기때문에 로드시간을 줄일수있음
    - 리소스를 chunk단위로 묶어 요청할 때만 다운받게하는 방식으로 해결
- 좋지않은 SEO
  - CSR에서는 앞서 언급한대로 html 안에 내용이 존재하지 않고 자바스크립트를 이용해 사용자와 상호작용 후 페이지 내용을 로드함
    → 검색엔진이 파악할 수 없음
  - [해결법]
    - pre-render - 사전에 HTML 파일들을 만든다
      검색 엔진이 크롤링하러 사이트에 들어왔을 때, 빈 html 대신 내용을 가져 갈 수 있게
      - 자세한 내용 [React]
        [https://velog.io/@ony/html-기본-SEO](https://velog.io/@ony/html-%EA%B8%B0%EB%B3%B8-SEO)

<br>
<br>

## **4. SEO(검색엔진최적화)**

: Search Engine Optimization ;  **검색엔진최적화**

우리가 무엇을 검색할때 검색하는 내용이 들어가는 컨텐츠를 노출시켜준다

검색엔진이 웹을 크롤링하며 페이지의 컨텐츠 색인을 생성하는 과정

<br>

## **5. SSR**

![SSR Image](https://user-images.githubusercontent.com/96935132/219910073-15502253-05ef-464e-8897-0192b27dc58b.png)

### 🟢 **정의**

: Server Side Rendering ; 서버쪽에서 랜더링한다!

준비된 HTML 을 보내준다

### 🟢 **과정**

서버에서 필요한 데이터를 모두 가져와 완전한 HTML 파일을 만든다

→ 동적으로 제어가 가능한 약간의 자바스크립트 소스코드와 함께 클라이언트에 전송

→ 잘 만들어진 HTML 문서를 받아와 바로 사용자에게 보여줌

### 🟢 **장점**

- CSR 보다 첫 페이지 로딩이 빨라짐 → 사용자가 기다리는 시간이 적다
- SEO 에서의 두각
  - 모든 데이터가 이미 HTML에 담겨진채로 브라우저에 전달되어 검색엔진최적화에 유리

### 🟢 **단점**

- 블링킹 이슈
  - 사용자가 클릭하면 전체적인 웹사이트를 다시 서버에서 받아오는것과 같아 썩 좋지않은 사용자경험을 얻을 수 있음
- 서버 과부하 생길 수 있음
  - 사용자가 많을수록 사용자가 요청할때마다 html 만들어야하고, 바뀌지 않아도 될 부분까지도 랜더링됨
- 동적으로 처리하는 자바스크립트를 아직 마저 다운로드하지못해, 사용자가 클릭해도 반응하지 않는 경우가 있음
  - TTV , **TTI** 사이의 공백

<br>

## **6. TTV & TTI**

### 🟢 **TTV (Time to View)**

: 사용자가 웹브라우저에서 내용을 **볼 수 있는** 시점

### 🟢 **TTI (Time to Interact)**

: 사용자가 웹브라우저에서 **인터랙션** 할 수 있는 시점

### 🟢 **CSR, SSR에서의 TTV, TTI 비교**

- CSR은 웹 사이트가 사용자에게 보여짐과 동시에 사용자와의 상호작용이 가능해짐<br>
  ⇒ TTV 와 TTI 가 동시에 이뤄짐<br>
  → 최종적으로 번들링해서 클라이언트에게 보내주는 JS파일을 어떻게 하면 효율적으로 분할해서 사용자가 첫화면을 볼 때 필수적인 것들만 보낼 수 있을지 고민해봐야함<br>

- SSR 은 TTV는 미리 이뤄지지만, 사용자가 웹 사이트를 볼 수 있는 시간과 상호작용 할 수 있는 공백 시간이 꽤 있는편이라 TTI 사이의 공백시간이 존재함<br>
  → 사용자가 보고 상호작용 할 수 있는 이 시간의 차이를 줄일 수 있는 방법에 대해 고민하거나 어떻게 하면 매끄러운 UI/UX를 제공할 수 있을지 고민해봐야함

<br>

## **7. SSG**

; Static Site Generator

- 정적인 정보를 다루는데 적합하므로, 바뀔일이 거의 없는 사이트, 캐싱해두면 좋은 사이트에 유용
- Ex) Gatsby, Next.js (원랜 강력한 SSR을 제공하는 라이브러리였지만, 요즘은 SSG도 지원)
- 리액트는 CSR이지만 Gatsby라는 Static Site Generator를 함께 사용하면 리액트로 만든 웹어플리케이션도 정적으로 웹페이지를 미리 생성해서 서버에 배포할 수 있게 → 모두 다 정적X, 동적 요소 추가가능(js이용)
  <br>
  <br>

## **8. Universal Rendering**

- **CSR + SSR/SSG**
- Isomorphic App (Universal rendering) (동일한 어플리케이션) : 클라이언트가 서버가 동일한코드가 동작하는 어플리케이션<br>
  → 예상과는 다른 결과를 마주할순있지만 초기로딩속도 보완, SEO 개선에 기존 CSR의 장점을 살릴수있음
- node js express, nest js → 프레임워크 <u>없이</u> 구현되도록
- [React] next..js (ssr, ssg 선택가능), gatsby (ssg에 최적화)<br> → <u>프레임워크 이용</u>

  - 리액트 + Next.js
    - 첫페이지는 서버에서 렌더링하여 빈 html이 아닌 준비된 html을 보내 검색 최적화 문제를 해결하고, 그 다음 페이지부터는 CSR 방식을 적용하여 필요한 데이터부분만 갱신해 서버의 부하를 줄이게 함
    - 사용이유 : pages 폴더 밑에 폴더 및 파일을 구성하면 자동으로 라우팅 처리가 되어 개발에 편리하고, 처음 웹페이지 로드 시 SSR로 SEO를 최적화하며 클라이언트와 상호작용 할 때는 CSR을 사용하여 필요한 데이터만 요청 할 수 있기 때문에 SSR과 CSR의 장점을 다 적용 할 수 있음
  - Vue + NUXT 이용

  - 단점 :  
    프레임워크를 사용하더라도 코드복잡도가 올라갔고 제어할수없는 블랙박스 영역이 존재할 수 있음

---

[**참고**]

[서버사이드 렌더링 (개발자라면 상식으로 알고 있어야 하는 개념 정리 ⭐️)](https://youtu.be/iZ9csAfU5Os)

[[10분 테코톡] 🎨 신세한탄의 CSR&SSR](https://www.youtube.com/watch?v=YuqB8D6eCKE)

[어서 와, SSR은 처음이지? - 도입 편](https://d2.naver.com/helloworld/7804182)

[SSR과 CSR 이 영상 하나로 끝내기! (SEO 해결 포함)](https://youtu.be/D71ByEIBWEs)
