<aside>
💡 rest 아키텍처 스타일을 따르는 api

</aside>

<aside>
🔥 RESTful API는 RESTful 웹 API를 나타내지만 REST API와 RESTful API는 같은 의미로 사용할 수 있음

</aside>

<aside>
🙅🏻‍♀️ 현재 대부분의 rest api는 rest api가 아님

</aside>

# REST

- 웹을 위한 아키텍처 스타일로 시작함
- 아키텍처 스타일은 제약조건의 집합
- API 작동 방식에 대한 조건을 부과하는 소프트웨어 아키텍처
- 대규모의 고성능 통신을 안정적으로 지원
- 여러 플랫폼에서 사용 가능

---

# API

- 다른 소프트웨어 시스템과 통신하기 위해 따라야 하는 규칙
- 웹 API는 클라이언트와 웹 리소스 사이의 게이트웨이

![캡처.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df57ed60-2084-4def-b71e-4126d9fee5e4/%EC%BA%A1%EC%B2%98.png)

---

# REST API를 구성하는 스타일(제약조건)

### client-server

- 클라이언트가 리소스에 대한 요청을 보내고 있으며 데이터 저장소와 연결되어 있지 않음
- 데이터 저장소는 서버 내부에 남아 있음
- 서버는 사용자 인터페이스와의 통신에 관여하지 않음
- 클라이언트와 서버는 상호 의존적으로 발전

### stateless

- 서버가 이전의 모든 요청과 독립적으로 클라이언트 요청을 완료하는 통신방법
- 클라이언트는 임의의 순서로 리소스를 요청할 수 있으며 모든 요청은 무상태이거나 다른 요청과 분리

### cache

- 서버 응답 시간을 개선하기 위해 일부 응답을 저장하는 프로세스인 캐싱을 지원

### uniform interface

- REST API를 구별하는 필수요소
    - **Identification of resources**
        - 자원을 식별할 수 있는 식별자가 있어야 함.
        - 자원의 상태는 변화하기 때문에 변하지 않는 식별자(URI)를 통해 식별
        - URI는 서버의 개별 자원에 대한 고유한 식별자를 사용
    - **Manipulation of resources through these representations**
        - 특정 표현을 통해 자원을 조작할 수 있어야함.
        - 클라이언트는 서버가 수정, 제거 또는 추가해야 하는 표현과 필요한 데이터를 보냄
        - 서버는 리소스를 자세히 설명하는 메타데이터를 전송
    - **Self-descriptive messages**
        - 클라이언트와 서버 간에 전송되는 메시지는 그 자체만으로도 스스로에 대해 충분히 설명할 수 있어야함.
        - 메시지에는 수신자가 이해할 수 있도록 모든 정보가 포함
        - 별도의 문서나 메시지에는 추가정보가 필요하지 않음
        - 각 메시지에는 서버가 요청을 구문 분석할 수 있는 충분한 정보가 있음
        - 클라이언트는 표현을 추가로 처리하는 방법에 대한 정보를 수신
        - 서버는 클라이언트가 리소스를 적절하게 사용할 수 있는 방법에 대한 메타데이터가 포함된 명확한 메시지를 전송
    - **Hypermedia as the engine of application state (HATEOAS)**
        - 하이퍼미디어를 어플리케이션 상태 관리 엔진으로 사용해야 함.
        - 클라이언트는 작업을 완료하는 데 필요한 관련 리소스에 대한 정보를 수신
        - 서버는 클라이언트가 더 많은 리소스를 동적으로 검색할 수 있도록 표현에 하이퍼링크를 넣어 전송

### layered system

- 아키텍처에서 클라이언트는 클라이언트와 서버 사이의 다른 승인된 중개자에게 연결할 수 있으며 여전히 서버로부터도 응답을 받음
- 서버는 요청을 다른 서버로 전달할 수도 있음
- 클라이언트 요청을 이행하기 위해 함께 작동하는 보안, 애플리케이션 및 비즈니스 로직과 같은 여러 계층으로 여러 서버에서 실행되도록 설계
- 클라이언트에 이런 계층은 보이지 않음

### code on demand

- 서버가 코드를 클라이언트에 전송하여 기능을 일시적으로 확장하거나 사용자 지정할 수 있음

---

# REST API 이점

### 확장성

- REST가 클라이언트-서버 상호 작용을 최적화하기 때문에 효율적으로 크기 조정할 수 있음
- 무상태는 서버가 과거 클라이언트 요청 정보를 유지할 필요가 없기 때문에 서버 로드를 제거
- 잘 관리된 캐싱은 일부 클라이언트-서버 상호 작용을 부분적으로 또는 완전히 제거
- 이러한 모든 기능은 성능을 저하시키는 통신 병목 현상을 일으키지 않으면서 확장성을 지원

### 유연성

- 완전한 클라이언트-서버 분리를 지원
- 각 부분이 독립적으로 발전할 수 있도록 다양한 서버 구성 요소를 단순화하고 분리
- 서버 애플리케이션의 플랫폼 또는 기술 변경은 클라이언트 애플리케이션에 영향을 주지 않음
- 애플리케이션 함수를 계층화하는 기능은 유연성을 더욱 향상시킴

### 독립성

- 사용되는 기술과 독립적
- API 설계에 영향을 주지 않고 다양한 프로그래밍 언어로 클라이언트 및 서버 애플리케이션을 모두 작성할 수 있음
- 통신에 영향을 주지 않고 양쪽의 기본 기술을 변경할 수 있음

---

# REST API가 동작하는 순서

- 인터넷 브라우징과 동일
- 클라이언트는 리소스가 필요할 때 API를 사용하여 서버에 접속
- 문서에 클라이언트가 REST API를 어떻게 사용해야 하는지 작성
    - 클라이언트가 API 문서에 따라 요청형식을 지정해서 서버에 요청을 전송
    - 서버가 클라이언트를 인증하고 해당 요청을 수행할 수 있는 권한이 클라이언트에 있는지 확인
    - 서버가 요청을 수신하고 내부적으로 처리
    - 서버가 클라이언트에 상태코드와 요청한 정보를 포함하는 응답을 반환
    

---

# REST API 요청

### 고유 리소스 식별자 (요청 엔드포인트)

- 서버는 url(리소스에 대한 경로) 등 고유한 리소스 식별자로 각 리소스를 식별
- http 헤더
    - 클라이언트와 서버 간에 교환되는 메타데이터
    - 요청 및 응답의 형식을 나타내고 요청 상태 등에 대한 정보를 제공
    - post, put이 성공적으로 작동하기 위한 데이터가 포함될 수 있음
    - 파라미터
        - 수행해야 할 작업에 대한 자세한 정보를 서버에 제공하는 파라미터가 포함될 수 있음
        - url 세부정보를 지정하는 경로 파라미터, 리소스에 대한 추가 정보를 요청하는 쿼리 파라미터, 클라이언트를 빠르게 인증하는 쿠키 파라미터

### REST API를 구현하기 위한 http 메소드

- get
    - 클라이언트가 서버에게 리소스를 요청할 떄 사용
    - 필요한 정보를 특정하기 위해 url 뒤에 query string을 추가하여 정보를 조회
    - url 뒤에 query string까지 포함해서 브라우저 히스토리에 남게 되고 캐시가 가능
    - query string은 url 주소 끝에 key : value 쌍으로 파라미터를 포함한 부분
- post
    - 서버에게 데이터 처리를 요청할 때 사용하는 메소드(주로 생성)
    - 전달할 데이터를 body 부분에 포함하여 통신
    - 브라우저 히스토리에 남지 않고 캐시도 불가능
    - post메시지를 받으면 꼭 리소스를 등록하는 것만 아니라 리소스 마다 다양하게 처리 함
    - 데이터를 생성하거나 변경하기도 하지만 특정 프로세스를 처리하기도 함
    - 동일한 요청을 여러번 전송하면 동일한 리소스를 여러번 생성하는 단점
- put
    - 리소스를 대체, 해당 리소스가 없으면 생성 (전체 업데이트)
    - post와 달리 동일한 put요청을 여러번 전송해도 결과는 동일
- patch
    - 리소스의 일부분을 수정 (일부 업데이트)
- delete
    - 리소스를 제거
    - 적절한 인증이 필요
    
    ![캡처2.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4291189a-8170-4b64-a2ac-58d3305243ed/%EC%BA%A1%EC%B2%982.png)
    

---

# REST API 인증 방법

- 응답을 보내기전에 먼저 요청을 인증하고, 서버에 자신의 신원을 증명
    
    ### http 인증
    
    - 기본 인증에서 클라이언트는 요청 헤더에 사용자 이름과 암호를 넣어 전송
    - 전달자 인증(bearer)은 요청 헤더에 토큰을  넣어 전송
        - 전달자 토큰은 서버가 로그인 요청에 대한 응답으로 생성하는 암호화된 문자열
    
    ### api 키
    
    - 서버는 클라이언트에 고유한 api 키를 할당하고, 클라이언트는 리소스에 액세스 할 때마다 고유한 api 키를 사용하여 인증
    - 클라이언트가 이 키를 전송해야 해서 네트워크 도난에 취약
    
    ### oauth
    
    - 보안을 위해 서버는 먼저 암호를 요청한 다음 권한 부여 프로세스를 완료하기 위해 추가 토큰을 요청
    - 특정 범위와 수명으로 언제든지 토큰을 확인
    

---

# REST API 서버 응답

### http status code

- 클라이언트가 보낸 http 요청에 대한 서버의 응답코드로, 상태 코드를 통해 요청의 성공/실패 여부를 판단
- 상황에 알맞는 status code를 response에 담아서 클라이언트에 넘겨줘야 함.
- 5개 클래스 (100 ~ 500번대)
    - 1 (정보) - 요청을 받았으며 작업을 계속
    - 2 (성공) - 클라이언트가 요청한 동작을 성공적으로 수신하여 이해했고 성공적으로 처리
    - 3 (리다이렉션) - 요청을 완료하기 위해 추가 작업 조치가 필요
    - 4 (클라이언트 오류) - 클라이언트의 요청에 문제가 있음
    - 5 (서버 오류) - 서버가 유효한 요청의 수행을 실패
- 대표적인 응답코드들
    - 200 (ok) - 요청이 성공 / 글조회 성공
    - 201 (created) - 리소스 생성 성공 / 글 작성 성공
    - 400 (bad request) - 데이터의 형식이 올바르지 않는 등 서버가 요청을 이해할 수 없음 / 올바르지 않은 형식의 데이터 입력
    - 401 (unauthorized) - 인증되지 않은 상태에서 인증이 필요한 리소스에 접근 / 로그인 전에 사용자 정보 요청
    - 403 (forbidden) - 인증된 상태에서 권한이 없는 리소스에 접근 / 일반 유저가 관리자 메뉴 접근
    - 404 (not found) - 요청한 route가 없음. 찾는 리소스가 없음 / 존재하지 않는 route에 요청
    - 502 (bad gateway) - 서버에서 예상하지 못한 에러가 발생 / 예외처리를 하지 않은 오류가 발생

### 메시지 본문

- 응답 본문에는 리소스 표현이 포함
- 서버는 요청 헤더에 포함된 내용을 기반으로 적절한 표현형식을 선택
- 클라이언트는 데이터 작성 방식을 일반 텍스트로 정의하는 xml 또는 json형식으로 정보를 요청할 수 있음.

### 헤더

- 응답에는 응답에 대한 헤더 또는 메타데이터도 포함 / 서버, 인코딩, 날짜 및 콘텐츠 유형과 같은 정보 포함



