# 

- G1GC는 여러 region으로 나눠 그 사이즈가 이전방식보다 작다. 그러면 GC가 예전방식보다 더 자주일어나는 것이 아닌가?
    - GC의 가장 큰 성능은 old generation 영역에서 일어나기때문에 young generation 영역이 자주 비워진다는 것은 크게보면 old generation 영역에서의 실행시간이 단축된다
    - region 의 크기는 사용하는 application에 따라 적절하게 조절해야한다
    
- CMS는 병렬적으로 일어나는데 그러면 stop the world 가 발생하지 않나?
    - stop the world가 필연적으로 발생함
    - 마크 과정이 처음에 잠깐 stop the world가 일어나고 동시에 마크과정이 일어나고, 마지막에 최종 마크할때 또 stop the world가 일어나서 최종적으로 stop the world 가 준다
    
- G1GC에서는 병렬적으로 진행되나?
    - region마다 가비지컬렉션이 따로일어나므로 병렬적으로 진행된다
    - 성능이 가장 좋은 이유 == region 마다 병렬적으로 진행되기 때문
    
- 다른 언어와 비교해서 자바를 선택한 이유
    - C의 과정에선 배열의 영역을 먼저 선언해주고 들어감 → malloc 메서드 실행하고 들어가면 선언안하고 들어가도되지만 free를 꼭 붙여줘 GC를 해줘야함
        
        → 자바를 사용할 때 자동으로 GC가 되므로 유용
        
    
- 자바 GC의 단점은?
    - 주기적으로 자동 실행되다보니, 이걸 사용할 상황의 예측이 힘들 수 있음
    - 자기가 원할때 자동으로 실행시킬 수 없는 상황
    
- old generation 옆에 perm 영역 → 버전 업그레이드 이후로 metaspace로 변경되었는데 그 차이는?
    - 기존엔 클래스와 메서드가 저장되는 영역,
    - 힙 영역 → Native 영역, 프로세스가 이용할수있는 메모리 자원을 충분히 이용할 수 있게

- 자바 가비지컬렉터를 만들때 설계자가 세운 가설 두가지

- Old 에서 Young 영역으로의 참조가 적다, 그에 관한 카드테이블에 대한 설명(어떤건지, 왜 필요한지)

- Young이랑 Old 중에 Old에서 GC가 더 오래걸리는 이유?

- Minor GC 에서의 임계점이 JVM에 의해 동적으로 정해지는 과정
    - 동적으로 정하는 이유
    
- age bit 은 어디에 있는 것인가?

- ZGC ? 왜 나오게 되었는지, 특징이 무엇인지?

- 멀티스레드 환경에서 아까 설명했던 힙 메모리는 어떻게 관리가 되는가?
    - young generation에 계속 할당이 되는데, 멀티스레드 환경에선 어떻게 이뤄지는지 (힙 메모리의 관점에서)
    - 하나의 메모리에 들어가면 발생할 수 있는 문제점
        - 스레드마다 에덴영역이 분리되어있음(G1GC)
    
- survival 영역을 두개로 나눈 이유는?
    
    자동 compacting!
    
- 자바의 system.gc 를 의도적으로 부르면 좋지않은데, 그 이유는 무엇인가?
